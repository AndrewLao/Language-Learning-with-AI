from dotenv import load_dotenv
from fastapi import APIRouter
from langgraph.graph import StateGraph, END, START
from langchain_openai import ChatOpenAI
from services.rag_store_qdrant import query_qdrant
from models.userschema import  SimpleMessageResponse
import os
from pymongo import MongoClient
import time

load_dotenv()

router = APIRouter()

# Simple in-memory conversation store to track per-chat quiz state
# Format: { chat_id: {"questions_asked": int, "answers_given": int, "score": int, "last_question": str, "finished": bool} }
conversation_store = {}

class AgentState(dict):
    user_id: str
    chat_id: str
    user_input: str
    memories: list
    docs: list
    response: str
    question: str

class ManagerAgent:
    def __init__(self, llm_model="gpt-5"):
        self.agents = {"general_agent": self.general_agent}
        self.router = self.default_router
        self.llm = ChatOpenAI(model=llm_model)
        self.mongo_client = MongoClient(os.environ.get("ATLAS_URI"))

        self.graph = self.build_graph()
        self.app = self.graph.compile()

    # Decide agent for the task
    # Another prompt has to go here if there are multiple agents for a task
    # Defaults to general
    def default_router(self, state: AgentState):
        print("Time default router:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        return {"route": "general_agent"}

    def general_agent(self, state: AgentState):
        print("Time general agent:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        context = "\n".join([m.page_content for m in state.get("memories", [])])
        refs = state.get("docs", [])
        print("Test refsdew:", state.get("docs"))
        prompt = f"""
        Based on the context ask me three yes/no questions about the topics" \
        "Two questions are from the context and one is generated by you to test my understanding." \
        "It follows format: Question <number>: <question_text> - Answer <number>: <answer and explaination> "\
        Context: {refs}
        """
        chat_id = state.get("chat_id")

        # Ensure a conversation record exists
        conv = conversation_store.setdefault(chat_id, {"questions_asked": 0, "answers_given": 0, "score": 0, "last_question": None, "finished": False})

        resp = self.llm.invoke(prompt)
        question_text = resp.content.strip()

        # Store the generated question and increment count
        conv["questions_asked"] = conv.get("questions_asked", 0) + 1
        conv["last_question"] = question_text

        return {"response": question_text, "question": question_text}

    # Aux step to filter incoming text
    def handle_user_prompt(self, state: AgentState):
        print("Time user prompt:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        return {"user_input": state["user_input"]}

    # Incomplete state for now until user memories updates are done
    # TODO Complete Function and Finish Short Term memory retrieval
    # TODO Make prompt to get memory if necessary to not use user input
    def retrieve_memories(self, state: AgentState):
        print("Time retrieve memories:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        return {"memories": []}

    def search_rag_documents(self, state: AgentState):
        print("Time search rag:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        query_text = state.get("user_input", "")

        try:
            # Add timeout and error handling
            search_result = query_qdrant('vietnamese_test_store', query_text, top_k=1)
            docs = [hit.payload.get("text", "") for hit in search_result]
            print("RAG Docs:", docs)
        except Exception as e:
            print(f"RAG search error: {e}")
            docs = ["Could not retrieve documents. Error: " + str(e)]
        
        return {"docs": docs}

    def planner(self, state: AgentState):
        # Another prompt goes here if we decide that there is a specialized case
        # Planner should not re-write the entire state; return only modified keys (none)
        return {}

    # Required because of graph layout
    # Handles updating both memories and rag document outputs
    def merge_docs(self, state: AgentState, **kwargs):
        print("Time merge docs:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        combined = state.get("memories", []) + state.get("docs", [])
        return {"docs": combined}

    def update_memory(self, state: AgentState):
        print("Time update memory:", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        return {}

    def build_graph(self):
        graph = StateGraph(AgentState)

        graph.add_node("input", self.handle_user_prompt)
        graph.add_node("memories", self.retrieve_memories)
        graph.add_node("rag_docs", self.search_rag_documents)
        graph.add_node("planner", self.planner)
        graph.add_node("general_agent", self.general_agent)
        graph.add_node("merge_docs", self.merge_docs)

        graph.add_edge(START, "input")
        graph.add_edge("input", "memories")
        graph.add_edge("memories", "rag_docs")
        graph.add_edge("rag_docs", "merge_docs")
        graph.add_edge("merge_docs", "planner")
        graph.add_edge("planner", "general_agent")
        graph.add_edge("general_agent", END)

        return graph

    # Executes the agent pipeline
    def invoke(self, user_id, chat_id, user_input):
        state = AgentState(
            user_id=user_id,
            chat_id=chat_id,
            user_input=user_input,
            memories=[],
            docs=[],
            response=""
        )
        return self.app.invoke(state, config={"configurable": {"chat_id": chat_id}})


@router.post("/invoke-agent-test", response_model=SimpleMessageResponse)
def invoke_agent(payload: dict):
    """

    For asking a question:
    {
        "input_string": "Topic to learn about",
        "user_id": "optional-user-id",
        "chat_id": "optional-chat-id"
    }
    """
    agent = ManagerAgent()

    chat_id = payload.get("chat_id")
    user_id = payload.get("user_id")

    # Use `input_string` as the single input field for both asking and answering
    input_string = payload.get("input_string", "")

    state = agent.invoke(user_id, chat_id, input_string)
   
    response_text = (
        state.get("response")
        if isinstance(state, dict)
        else getattr(state, "response", "")
    )
    return {"result": response_text}
